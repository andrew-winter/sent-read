scrapes <- c("httr", "geniusr", "purrr", "tidytext", "textdata")
lapply(scrapes, require, character.only = TRUE)
baseURL <- "https://api.genius.com/search?q="
token <- "Z12YlAUALbWknjemUTrwHSnGkbbCpbprSqoVbt7yXhjz0sDX_v3pRnNPTq8k2Ldm"
afinn <- get_sentiments("afinn")
bing <- get_sentiments("bing")
loughran <- get_sentiments("loughran")
afinn_join <- function(song) {song %>% 
  anti_join(stop_words, by = "word") %>% 
    inner_join(afinn, by = "word")}
positive_sent <- function(song) {sum(song$value[song$value > 0])}
negative_sent <- function(song) {sum(song$value[song$value < 0])}
bing_positive_sent <- function(song) {
  song$sentiment[song$sentiment == "positive"] %>% length()}
bing_negative_sent <- function(song) {
  song$sentiment[song$sentiment == "negative"] %>% length() *-1}
song_length <- function(song) {song %>% bind_rows %>% nrow}


sear1 <- search_song(search_term = "brockhampton")
toplist <- list()
# BROCKHAMPTON's top three songs on Genius are from the Saturation trilogy
for (i in 1:3) {
  toplist[[i]] <- get_song_meta(sear1$song_id[[i]])$album_id
}
# Turn this into a general function, "put unique album ids in a vector"
toplist[[4]] <- toplist[[1]]
toplist[[1]] <- toplist[[3]]
toplist[[3]] <- toplist[[4]]
toplist[[4]] <- NULL 
sattri <- lapply(toplist, scrape_tracklist)
sat3 <- list()
sat2 <- list()
sat1 <- list()
for (song in 1:nrow(sattri[[1]])) {
  sat1[[song]] <- scrape_lyrics_url(sattri[[1]][[song,3]])}
for (song in 1:nrow(sattri[[2]])) {
  sat2[[song]] <- scrape_lyrics_url(sattri[[2]][[song,3]])}
for (song in 1:nrow(sattri[[3]])) {
  sat3[[song]] <- scrape_lyrics_url(sattri[[3]][[song,3]])}
SatLyrics <- list(sat1, sat2, sat3)
SatTokens <- list()
for (album in 1:3) {
  SatTokens[[album]] <- lapply(SatLyrics[[album]], unnest_tokens, word, line)}
SatSentiment <- list()
for (album in 1:3) {
  SatSentiment[[album]] <- cbind.data.frame(
    sattri[[album]]$song_title, 
    sapply(lapply(SatTokens[[album]], afinn_join), positive_sent),
    sapply(lapply(SatTokens[[album]], afinn_join), negative_sent))
  names(SatSentiment[[album]]) <- c("song", "pos", "neg")
}
SST <- bind_rows(SatSentiment, .id = "album") %>% as_tibble()
# Important line that makes sure ggplot doesn't screw up the order-------------
SST$song <- factor(SST$song, levels = unique(as.character(SST$song)) %>% rev)
SST <- SST %>% mutate(diff = pos - neg)

# Should be able to put default aesthetics/formats in ggplot args, dunno why not
labels <- c("SATURATION", "SATURATION II", "SATURATION III")
names(labels) <- c("1", "2", "3")
SSTPlot <- ggplot(data = SST, aes(x = song)) + 
  geom_col(aes(y = pos), linetype = 1, color = "black", alpha = 0.7, 
    fill = "springgreen") +  
  geom_col(aes(y = neg), linetype = 1, color = "black", alpha = 0.7, 
    fill = "steelblue2") +
  facet_grid(. ~ album, labeller = labeller(album = labels)) +
  coord_flip() + labs(title = "Lyrical Sentiment in the SATURATION Trilogy", 
    x = "song", y = "sentiment by individual words")
print(SSTPlot)

order <- c(c(1:17), c(1:16), c(1:15))
SST_alt <- SST %>% mutate(order = order)
SSTPlot_alt <- ggplot(SST_alt, aes(x = order)) +
  geom_col(aes(y = pos), linetype = 1, color = "black", alpha = 0.7, 
    fill = "springgreen") +  
  geom_col(aes(y = neg), linetype = 1, color = "black", alpha = 0.7, 
    fill = "steelblue2") +
  facet_grid(album ~ ., labeller = labeller(album = labels)) +
  labs(title = "Lyrical Sentiment in the SATURATION Trilogy", 
    x = "track number", y = "sentiment by individual lyrics")
print(SSTPlot_alt)


# Possible problem-- compared the sentiments when using custom 'afinn_join()'
  # versus just 'inner_join()' with the afinn lexicon. The difference seems to
  # be whether or not 'anti_join(stop_words)' is used. Looking at just a few
  # songs, seems to undercount positive lyrics for BROCKHAMPTON and undercount
  # both positive AND negative lyrics in Hamilton
# Might be a worthwhile addition to make two additions to plot(s)
  # line that measures difference between positive and negative sentiment, and
  # line that measures difference between including stop_words or not

# A few notes:
  # One album at a time is pretty darn easy, once the kinks are worked out
  # Can improve the integrity of the visualization by
    # controlling for the length of the song, 
    # controlling for RELATIVE sentiment,
    # comparing between different lexicons,
    # comparing between different methods (stop_words or not)


Hammeta <- search_song(search_term = "Hamilton")$song_id[[1]] %>% get_song_meta()
HamLyrics <- list()
HamLyrics <- lapply(scrape_tracklist(Hammeta$album_id)$song_lyrics_url,  
  scrape_lyrics_url)
HamTokens <- lapply(HamLyrics, unnest_tokens, word, line)
HamSent <- list()
for (song in 1:46) {
  HamSent[[song]] <- cbind.data.frame(
    HamTokens[[song]]$song_name[[1]],
    positive_sent(lapply(HamTokens, inner_join, afinn, by = "word")[[song]]),
    negative_sent(lapply(HamTokens, inner_join, afinn, by = "word")[[song]])
  )}
HamSentiment <- bind_rows(HamSent)
names(HamSentiment) <- c("song", "pos", "neg")
HamSentiment

HamSentiment$song <- factor(HamSentiment$song, 
  levels = unique(as.character(HamSentiment$song)) %>% rev)
HamPlot <- ggplot(HamSentiment, aes(x = song)) +
  geom_col(aes(y = pos), linetype = 1, color = "black", alpha = 0.6, 
    fill = "sienna1") +
  geom_col(aes(y = neg), linetype = 1, color = "black", alpha = 0.6, 
    fill = "skyblue2") +
  coord_flip() + labs(title = "Lyrical Sentiment in Hamilton", x = "song",
    y = "sentiment by individual words")
print(HamPlot)

HamSentiment_alt <- HamSentiment %>% 
  mutate(normal_pos = abs((pos - mean(HamSentiment$pos))/46), 
    normal_neg = -1 * abs((neg - mean(HamSentiment$neg))/46))
HamPlot_alt <- HamSentiment_alt %>% ggplot(aes(x = song)) + 
  geom_col(aes(y = normal_pos), linetype = 1, color = "black", alpha = 0.6, 
    fill = "sienna1") +
  geom_col(aes(y = normal_neg), linetype = 1, color = "black", alpha = 0.6, 
    fill = "skyblue2") + coord_flip() + 
  labs(title = "Normalized Sentiment in Hamilton", x = "song", 
    y = "sentiment by individual words")
print(HamPlot_alt)



# Rough-and-tumble, quick sentiment function-------------------------------------
quick_lyric_sentiment <- function(search) {
# Assuming the first result of the search is the album you're looking for...
  Meta <- search_song(search)$song_id[[1]] %>% get_song_meta()
  Lyrics <- list()
  Lyrics <- lapply(scrape_tracklist(Meta$album_id)$song_lyrics_url,
    scrape_lyrics_url)
  Tokens <- lapply(Lyrics, unnest_tokens, word, line)
  Sent <- list()
  for (song in 1:length(Lyrics)) {
    Sent[[song]] <- cbind.data.frame(
      Tokens[[song]]$song_name[[1]],
      positive_sent(lapply(Tokens, inner_join, afinn, by = "word")[[song]]),
      negative_sent(lapply(Tokens, inner_join, afinn, by = "word")[[song]])
    )}
  Sentiment <- bind_rows(Sent)
  names(Sentiment) <- c("song", "pos", "neg")
  Sentiment$song <- factor(Sentiment$song, 
    levels = unique(as.character(Sentiment$song)) %>% rev)
return(Sentiment)
}


BeatlesAlbums <- read.csv("BeatlesAlbums.csv", stringsAsFactors = FALSE) %>% 
  as_tibble()
# Wrote ugly code to get these album_ids; easier to preserve them then the code
BeatlesAlbum_ids <- c(27343, 29389, 27184, 21431, 22530, 12347, 17342, 11039, 
  12416, 16366, 29391, 12411, 29393)
BeatlesTracklists <- lapply(BeatlesAlbum_ids, scrape_tracklist)
BeatlesLyrics <- list()
for (album in 1:13) {
  BeatlesLyrics[[album]] <- lapply(BeatlesTracklists[[album]]$song_lyrics_url, 
    scrape_lyrics_url)}
BeatlesTokens <- list()
for (album in 1:13) {
  BeatlesTokens[[album]] <- lapply(BeatlesLyrics[[album]], 
    unnest_tokens, word, line)}

BeatlesSentA <- list() # afinn_join()
BeatlesSentB <- list() # inner_join(bing)
BeatlesSentC <- list() # inner_join(afinn)
for (album in 1:13) {
  BeatlesSentA[[album]] <- cbind.data.frame(
    BeatlesTracklists[[album]]$song_title,
    lapply(BeatlesTokens[[album]], afinn_join) %>% sapply(positive_sent),
    lapply(BeatlesTokens[[album]], afinn_join) %>% sapply(negative_sent),
    sapply(BeatlesTokens[[album]], song_length)
    )
  BeatlesSentB[[album]] <- cbind.data.frame(
    BeatlesTracklists[[album]]$song_title,
    lapply(BeatlesTokens[[album]], inner_join, bing, "word") %>%
      sapply(bing_positive_sent),
    lapply(BeatlesTokens[[album]], inner_join, bing, "word") %>%
      sapply(bing_negative_sent),
    sapply(BeatlesTokens[[album]], song_length)
    )
  BeatlesSentC[[album]] <- cbind.data.frame(
    BeatlesTracklists[[album]]$song_title,
    lapply(BeatlesTokens[[album]], inner_join, afinn, "word") %>%
      sapply(positive_sent),
    lapply(BeatlesTokens[[album]], inner_join, afinn, "word") %>%
      sapply(negative_sent),
    sapply(BeatlesTokens[[album]], song_length)
    )
  names(BeatlesSentA[[album]]) <- c("song", "pos", "neg", "wlength")
  names(BeatlesSentB[[album]]) <- c("song", "pos", "neg", "wlength")
  names(BeatlesSentC[[album]]) <- c("song", "pos", "neg", "wlength")
}

B <- bind_rows(BeatlesSentB, .id = "album") %>% as_tibble()
C <- bind_rows(BeatlesSentC, .id = "album") %>% as_tibble()

A <- bind_rows(BeatlesSentA, .id = "album") %>% as_tibble()
A <- A %>% mutate(dif = pos + neg)
BeatlesSimple <- bind_rows(A,B,C, .id = "method")

# Set to factors for ordering in ggplot
# Duplicate songs: "Yellow Submarine" and "All You Need Is Love"
A$song[[152]] <- "yellow submarine"
A$song[[157]] <- "all you need is love"
A$song <- factor(A$song, levels = unique(as.character(A$song)))
A$album <- factor(A$album, levels = unique(as.character(A$album)))

A2 <- A %>% mutate(pos2 = 
  abs( pos * (wlength-mean(wlength)/sd(wlength)) ), neg2 =
  -1 * abs( neg * (wlength-mean(wlength)/sd(wlength)) ) )

A3 <- A %>% mutate(pos3 = pos/wlength, neg3 = neg/wlength)


BeatlesPlotA <- ggplot(A, aes(x = song), linetype = 1) + 
  geom_col(aes(y = pos, fill = album), color = "black", alpha = 0.6) +
  geom_col(aes(y = neg), color = "black", alpha = 0.4) +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "none") +
  labs(title = "Half of What I Say is Meaningless", 
       subtitle = "Sentiment Analysis of The Beatles' Lyrics",
       y = "negativity / positivity")

BeatlesPlotA3 <- ggplot(A3, aes(x = song), linetype = 1) + 
  geom_col(aes(y = pos3, fill = album), color = "black", alpha = 0.6) +
  geom_col(aes(y = neg3), color = "black", alpha = 0.4) +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "none") +
  labs(title = "Half of What I Say is Meaningless", 
       subtitle = "Sentiment Analysis of The Beatles' Lyrics",
       y = "negativity / positivity")
print(BeatlesPlotA3)

BeatlesPlotA +
  annotate(geom = "text", x = 121, y = -30, angle = 90, size = 4,
    label = "All You Need Is Love") +
  annotate(geom = "text", x = 170, y = 40, angle = 90, size = 4,
    label = "I Want You (She's So Heavy)") +
  annotate(geom = "text", x = 160, y = -30, angle = 90, size = 3,
    label = "George Martin's songs on Yellow Submarine")


print(BeatlesPlotA)

BeatlesLength <- ggplot(A, aes(x = album, y = wlength)) + geom_boxplot() +
  scale_x_discrete(labels = BeatlesAlbums$Title)
print(BeatlesLength)
